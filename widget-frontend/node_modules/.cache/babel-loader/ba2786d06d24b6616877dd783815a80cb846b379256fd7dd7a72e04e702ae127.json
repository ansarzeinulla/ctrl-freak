{"ast":null,"code":"'use client';\n\nimport { useRef, useMemo, useEffect } from 'react';\nimport { useCallbackRef } from '../utils/use-callback-ref/use-callback-ref.mjs';\nfunction useDebouncedCallback(callback, options) {\n  const {\n    delay,\n    flushOnUnmount,\n    leading\n  } = typeof options === \"number\" ? {\n    delay: options,\n    flushOnUnmount: false,\n    leading: false\n  } : options;\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = useRef(0);\n  const lastCallback = useMemo(() => {\n    const currentCallback = Object.assign(function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      window.clearTimeout(debounceTimerRef.current);\n      const isFirstCall = currentCallback._isFirstCall;\n      currentCallback._isFirstCall = false;\n      function clearTimeoutAndLeadingRef() {\n        window.clearTimeout(debounceTimerRef.current);\n        debounceTimerRef.current = 0;\n        currentCallback._isFirstCall = true;\n      }\n      if (leading && isFirstCall) {\n        handleCallback(...args);\n        const resetLeadingState = () => {\n          clearTimeoutAndLeadingRef();\n        };\n        const flush2 = () => {\n          if (debounceTimerRef.current !== 0) {\n            clearTimeoutAndLeadingRef();\n            handleCallback(...args);\n          }\n        };\n        const cancel2 = () => {\n          clearTimeoutAndLeadingRef();\n        };\n        currentCallback.flush = flush2;\n        currentCallback.cancel = cancel2;\n        debounceTimerRef.current = window.setTimeout(resetLeadingState, delay);\n        return;\n      }\n      if (leading && !isFirstCall) {\n        const flush2 = () => {\n          if (debounceTimerRef.current !== 0) {\n            clearTimeoutAndLeadingRef();\n            handleCallback(...args);\n          }\n        };\n        const cancel2 = () => {\n          clearTimeoutAndLeadingRef();\n        };\n        currentCallback.flush = flush2;\n        currentCallback.cancel = cancel2;\n        const resetLeadingState = () => {\n          clearTimeoutAndLeadingRef();\n        };\n        debounceTimerRef.current = window.setTimeout(resetLeadingState, delay);\n        return;\n      }\n      const flush = () => {\n        if (debounceTimerRef.current !== 0) {\n          clearTimeoutAndLeadingRef();\n          handleCallback(...args);\n        }\n      };\n      const cancel = () => {\n        clearTimeoutAndLeadingRef();\n      };\n      currentCallback.flush = flush;\n      currentCallback.cancel = cancel;\n      debounceTimerRef.current = window.setTimeout(flush, delay);\n    }, {\n      flush: () => {},\n      cancel: () => {},\n      _isFirstCall: true\n    });\n    return currentCallback;\n  }, [handleCallback, delay, leading]);\n  useEffect(() => () => {\n    if (flushOnUnmount) {\n      lastCallback.flush();\n    } else {\n      lastCallback.cancel();\n    }\n  }, [lastCallback, flushOnUnmount]);\n  return lastCallback;\n}\nexport { useDebouncedCallback };","map":{"version":3,"names":["useDebouncedCallback","callback","options","delay","flushOnUnmount","leading","handleCallback","useCallbackRef","debounceTimerRef","useRef","lastCallback","useMemo","currentCallback","Object","assign","_len","arguments","length","args","Array","_key","window","clearTimeout","current","isFirstCall","_isFirstCall","clearTimeoutAndLeadingRef","resetLeadingState","flush2","flush","cancel2","cancel","setTimeout","useEffect"],"sources":["/Users/ansarzeinulla/Desktop/ctrl-freak/widget-frontend/node_modules/@mantine/hooks/src/use-debounced-callback/use-debounced-callback.ts"],"sourcesContent":["import { useEffect, useMemo, useRef } from 'react';\nimport { useCallbackRef } from '../utils';\n\nexport interface UseDebouncedCallbackOptions {\n  delay: number;\n  flushOnUnmount?: boolean;\n  leading?: boolean;\n}\n\nexport type UseDebouncedCallbackReturnValue<T extends (...args: any[]) => any> = ((\n  ...args: Parameters<T>\n) => void) & { flush: () => void; cancel: () => void };\n\nexport function useDebouncedCallback<T extends (...args: any[]) => any>(\n  callback: T,\n  options: number | UseDebouncedCallbackOptions\n) {\n  const { delay, flushOnUnmount, leading } =\n    typeof options === 'number'\n      ? { delay: options, flushOnUnmount: false, leading: false }\n      : options;\n\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = useRef(0);\n\n  const lastCallback = useMemo(() => {\n    const currentCallback = Object.assign(\n      (...args: Parameters<T>) => {\n        window.clearTimeout(debounceTimerRef.current);\n\n        const isFirstCall = currentCallback._isFirstCall;\n        currentCallback._isFirstCall = false;\n\n        function clearTimeoutAndLeadingRef() {\n          window.clearTimeout(debounceTimerRef.current);\n          debounceTimerRef.current = 0;\n          currentCallback._isFirstCall = true;\n        }\n\n        if (leading && isFirstCall) {\n          handleCallback(...args);\n\n          const resetLeadingState = () => {\n            clearTimeoutAndLeadingRef();\n          };\n\n          const flush = () => {\n            if (debounceTimerRef.current !== 0) {\n              clearTimeoutAndLeadingRef();\n              handleCallback(...args);\n            }\n          };\n\n          const cancel = () => {\n            clearTimeoutAndLeadingRef();\n          };\n\n          currentCallback.flush = flush;\n          currentCallback.cancel = cancel;\n          debounceTimerRef.current = window.setTimeout(resetLeadingState, delay);\n          return;\n        }\n\n        if (leading && !isFirstCall) {\n          const flush = () => {\n            if (debounceTimerRef.current !== 0) {\n              clearTimeoutAndLeadingRef();\n              handleCallback(...args);\n            }\n          };\n\n          const cancel = () => {\n            clearTimeoutAndLeadingRef();\n          };\n\n          currentCallback.flush = flush;\n          currentCallback.cancel = cancel;\n\n          const resetLeadingState = () => {\n            clearTimeoutAndLeadingRef();\n          };\n          debounceTimerRef.current = window.setTimeout(resetLeadingState, delay);\n          return;\n        }\n\n        const flush = () => {\n          if (debounceTimerRef.current !== 0) {\n            clearTimeoutAndLeadingRef();\n            handleCallback(...args);\n          }\n        };\n\n        const cancel = () => {\n          clearTimeoutAndLeadingRef();\n        };\n\n        currentCallback.flush = flush;\n        currentCallback.cancel = cancel;\n        debounceTimerRef.current = window.setTimeout(flush, delay);\n      },\n      {\n        flush: () => {},\n        cancel: () => {},\n        _isFirstCall: true,\n      }\n    );\n    return currentCallback;\n  }, [handleCallback, delay, leading]);\n\n  useEffect(\n    () => () => {\n      if (flushOnUnmount) {\n        lastCallback.flush();\n      } else {\n        lastCallback.cancel();\n      }\n    },\n    [lastCallback, flushOnUnmount]\n  );\n\n  return lastCallback;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}