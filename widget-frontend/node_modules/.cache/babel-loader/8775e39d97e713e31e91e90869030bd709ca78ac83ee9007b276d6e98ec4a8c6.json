{"ast":null,"code":"'use client';\n\nimport { useRef } from 'react';\nimport { useForceUpdate } from '../use-force-update/use-force-update.mjs';\nfunction readonlySetLikeToSet(input) {\n  if (input instanceof Set) {\n    return input;\n  }\n  const result = /* @__PURE__ */new Set();\n  for (const item of input) {\n    result.add(item);\n  }\n  return result;\n}\nfunction useSet(values) {\n  const setRef = useRef(new Set(values));\n  const forceUpdate = useForceUpdate();\n  setRef.current.add = function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const res = Set.prototype.add.apply(setRef.current, args);\n    forceUpdate();\n    return res;\n  };\n  setRef.current.clear = function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    Set.prototype.clear.apply(setRef.current, args);\n    forceUpdate();\n  };\n  setRef.current.delete = function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    const res = Set.prototype.delete.apply(setRef.current, args);\n    forceUpdate();\n    return res;\n  };\n  setRef.current.union = other => {\n    const result = new Set(setRef.current);\n    readonlySetLikeToSet(other).forEach(item => result.add(item));\n    return result;\n  };\n  setRef.current.intersection = other => {\n    const result = /* @__PURE__ */new Set();\n    const otherSet = readonlySetLikeToSet(other);\n    setRef.current.forEach(item => {\n      if (otherSet.has(item)) {\n        result.add(item);\n      }\n    });\n    return result;\n  };\n  setRef.current.difference = other => {\n    const result = /* @__PURE__ */new Set();\n    const otherSet = readonlySetLikeToSet(other);\n    setRef.current.forEach(item => {\n      if (!otherSet.has(item)) {\n        result.add(item);\n      }\n    });\n    return result;\n  };\n  setRef.current.symmetricDifference = other => {\n    const result = /* @__PURE__ */new Set();\n    const otherSet = readonlySetLikeToSet(other);\n    setRef.current.forEach(item => {\n      if (!otherSet.has(item)) {\n        result.add(item);\n      }\n    });\n    otherSet.forEach(item => {\n      if (!setRef.current.has(item)) {\n        result.add(item);\n      }\n    });\n    return result;\n  };\n  return setRef.current;\n}\nexport { readonlySetLikeToSet, useSet };","map":{"version":3,"names":["readonlySetLikeToSet","input","Set","result","item","add","useSet","values","setRef","useRef","forceUpdate","useForceUpdate","current","_len","arguments","length","args","Array","_key","res","prototype","apply","clear","_len2","_key2","delete","_len3","_key3","union","other","forEach","intersection","otherSet","has","difference","symmetricDifference"],"sources":["/Users/ansarzeinulla/Desktop/negro/widget-frontend/node_modules/@mantine/hooks/src/use-set/use-set.ts"],"sourcesContent":["import { useRef } from 'react';\nimport { useForceUpdate } from '../use-force-update/use-force-update';\n\nexport function readonlySetLikeToSet<T>(input: ReadonlySetLike<T>): Set<T> {\n  if (input instanceof Set) {\n    return input;\n  }\n  const result = new Set<T>();\n  for (const item of input as any) {\n    result.add(item);\n  }\n  return result;\n}\n\nexport function useSet<T>(values?: T[]): Set<T> {\n  const setRef = useRef(new Set(values));\n  const forceUpdate = useForceUpdate();\n\n  setRef.current.add = (...args) => {\n    const res = Set.prototype.add.apply(setRef.current, args);\n    forceUpdate();\n    return res;\n  };\n\n  setRef.current.clear = (...args) => {\n    Set.prototype.clear.apply(setRef.current, args);\n    forceUpdate();\n  };\n\n  setRef.current.delete = (...args) => {\n    const res = Set.prototype.delete.apply(setRef.current, args);\n    forceUpdate();\n    return res;\n  };\n\n  setRef.current.union = <U>(other: ReadonlySetLike<U>): Set<T | U> => {\n    const result = new Set<T | U>(setRef.current as Set<T>);\n    readonlySetLikeToSet(other).forEach((item) => result.add(item));\n    return result;\n  };\n\n  setRef.current.intersection = <U>(other: ReadonlySetLike<U>): Set<T & U> => {\n    const result = new Set<T & U>();\n    const otherSet = readonlySetLikeToSet(other);\n    setRef.current.forEach((item) => {\n      if (otherSet.has(item as any)) {\n        result.add(item as T & U);\n      }\n    });\n    return result;\n  };\n\n  setRef.current.difference = <U>(other: ReadonlySetLike<U>): Set<T> => {\n    const result = new Set<T>();\n    const otherSet = readonlySetLikeToSet(other);\n    setRef.current.forEach((item) => {\n      if (!otherSet.has(item as any)) {\n        result.add(item);\n      }\n    });\n    return result;\n  };\n\n  setRef.current.symmetricDifference = <U>(other: ReadonlySetLike<U>): Set<T | U> => {\n    const result = new Set<T | U>();\n    const otherSet = readonlySetLikeToSet(other);\n\n    setRef.current.forEach((item) => {\n      if (!otherSet.has(item as any)) {\n        result.add(item);\n      }\n    });\n\n    otherSet.forEach((item) => {\n      if (!setRef.current.has(item as any)) {\n        result.add(item);\n      }\n    });\n\n    return result;\n  };\n\n  return setRef.current;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}