{"ast":null,"code":"'use client';\n\nimport { findElementAncestor } from '../find-element-ancestor/find-element-ancestor.mjs';\nfunction getPreviousIndex(current, elements, loop) {\n  for (let i = current - 1; i >= 0; i -= 1) {\n    if (!elements[i].disabled) {\n      return i;\n    }\n  }\n  if (loop) {\n    for (let i = elements.length - 1; i > -1; i -= 1) {\n      if (!elements[i].disabled) {\n        return i;\n      }\n    }\n  }\n  return current;\n}\nfunction getNextIndex(current, elements, loop) {\n  for (let i = current + 1; i < elements.length; i += 1) {\n    if (!elements[i].disabled) {\n      return i;\n    }\n  }\n  if (loop) {\n    for (let i = 0; i < elements.length; i += 1) {\n      if (!elements[i].disabled) {\n        return i;\n      }\n    }\n  }\n  return current;\n}\nfunction onSameLevel(target, sibling, parentSelector) {\n  return findElementAncestor(target, parentSelector) === findElementAncestor(sibling, parentSelector);\n}\nfunction createScopedKeydownHandler(_ref) {\n  let {\n    parentSelector,\n    siblingSelector,\n    onKeyDown,\n    loop = true,\n    activateOnFocus = false,\n    dir = \"rtl\",\n    orientation\n  } = _ref;\n  return event => {\n    var _findElementAncestor;\n    onKeyDown === null || onKeyDown === void 0 || onKeyDown(event);\n    const elements = Array.from(((_findElementAncestor = findElementAncestor(event.currentTarget, parentSelector)) === null || _findElementAncestor === void 0 ? void 0 : _findElementAncestor.querySelectorAll(siblingSelector)) || []).filter(node => onSameLevel(event.currentTarget, node, parentSelector));\n    const current = elements.findIndex(el => event.currentTarget === el);\n    const _nextIndex = getNextIndex(current, elements, loop);\n    const _previousIndex = getPreviousIndex(current, elements, loop);\n    const nextIndex = dir === \"rtl\" ? _previousIndex : _nextIndex;\n    const previousIndex = dir === \"rtl\" ? _nextIndex : _previousIndex;\n    switch (event.key) {\n      case \"ArrowRight\":\n        {\n          if (orientation === \"horizontal\") {\n            event.stopPropagation();\n            event.preventDefault();\n            elements[nextIndex].focus();\n            activateOnFocus && elements[nextIndex].click();\n          }\n          break;\n        }\n      case \"ArrowLeft\":\n        {\n          if (orientation === \"horizontal\") {\n            event.stopPropagation();\n            event.preventDefault();\n            elements[previousIndex].focus();\n            activateOnFocus && elements[previousIndex].click();\n          }\n          break;\n        }\n      case \"ArrowUp\":\n        {\n          if (orientation === \"vertical\") {\n            event.stopPropagation();\n            event.preventDefault();\n            elements[_previousIndex].focus();\n            activateOnFocus && elements[_previousIndex].click();\n          }\n          break;\n        }\n      case \"ArrowDown\":\n        {\n          if (orientation === \"vertical\") {\n            event.stopPropagation();\n            event.preventDefault();\n            elements[_nextIndex].focus();\n            activateOnFocus && elements[_nextIndex].click();\n          }\n          break;\n        }\n      case \"Home\":\n        {\n          event.stopPropagation();\n          event.preventDefault();\n          !elements[0].disabled && elements[0].focus();\n          break;\n        }\n      case \"End\":\n        {\n          event.stopPropagation();\n          event.preventDefault();\n          const last = elements.length - 1;\n          !elements[last].disabled && elements[last].focus();\n          break;\n        }\n    }\n  };\n}\nexport { createScopedKeydownHandler };","map":{"version":3,"names":["getPreviousIndex","current","elements","loop","i","disabled","length","getNextIndex","onSameLevel","target","sibling","parentSelector","findElementAncestor","createScopedKeydownHandler","_ref","siblingSelector","onKeyDown","activateOnFocus","dir","orientation","event","_findElementAncestor","Array","from","currentTarget","querySelectorAll","filter","node","findIndex","el","_nextIndex","_previousIndex","nextIndex","previousIndex","key","stopPropagation","preventDefault","focus","click","last"],"sources":["/Users/ansarzeinulla/Desktop/negro/widget-frontend/node_modules/@mantine/core/src/core/utils/create-scoped-keydown-handler/create-scoped-keydown-handler.ts"],"sourcesContent":["import { findElementAncestor } from '../find-element-ancestor/find-element-ancestor';\n\nfunction getPreviousIndex(current: number, elements: HTMLButtonElement[], loop: boolean) {\n  for (let i = current - 1; i >= 0; i -= 1) {\n    if (!elements[i].disabled) {\n      return i;\n    }\n  }\n\n  if (loop) {\n    for (let i = elements.length - 1; i > -1; i -= 1) {\n      if (!elements[i].disabled) {\n        return i;\n      }\n    }\n  }\n\n  return current;\n}\n\nfunction getNextIndex(current: number, elements: HTMLButtonElement[], loop: boolean) {\n  for (let i = current + 1; i < elements.length; i += 1) {\n    if (!elements[i].disabled) {\n      return i;\n    }\n  }\n\n  if (loop) {\n    for (let i = 0; i < elements.length; i += 1) {\n      if (!elements[i].disabled) {\n        return i;\n      }\n    }\n  }\n\n  return current;\n}\n\n/** Validates that target element is on the same level as sibling, used to filter out children that have the same sibling selector */\nfunction onSameLevel(\n  target: HTMLButtonElement,\n  sibling: HTMLButtonElement,\n  parentSelector: string\n) {\n  return (\n    findElementAncestor(target, parentSelector) === findElementAncestor(sibling, parentSelector)\n  );\n}\n\ninterface GetElementsSiblingsInput {\n  /** Selector used to find parent node, for example '[role=\"tablist\"]', '.mantine-Text-root' */\n  parentSelector: string;\n\n  /** Selector used to find element siblings, for example '[data-tab]' */\n  siblingSelector: string;\n\n  /** Determines whether next/previous indices should loop */\n  loop?: boolean;\n\n  /** Determines which arrow keys will be used */\n  orientation: 'vertical' | 'horizontal';\n\n  /** Text direction */\n  dir?: 'rtl' | 'ltr';\n\n  /** Determines whether element should be clicked when focused with keyboard event */\n  activateOnFocus?: boolean;\n\n  /** External keydown event */\n  onKeyDown?: (event: React.KeyboardEvent<HTMLButtonElement>) => void;\n}\n\nexport function createScopedKeydownHandler({\n  parentSelector,\n  siblingSelector,\n  onKeyDown,\n  loop = true,\n  activateOnFocus = false,\n  dir = 'rtl',\n  orientation,\n}: GetElementsSiblingsInput) {\n  return (event: React.KeyboardEvent<HTMLButtonElement>) => {\n    onKeyDown?.(event);\n\n    const elements = Array.from(\n      findElementAncestor(event.currentTarget, parentSelector)?.querySelectorAll<HTMLButtonElement>(\n        siblingSelector\n      ) || []\n    ).filter((node) => onSameLevel(event.currentTarget, node, parentSelector));\n\n    const current = elements.findIndex((el) => event.currentTarget === el);\n    const _nextIndex = getNextIndex(current, elements, loop);\n    const _previousIndex = getPreviousIndex(current, elements, loop);\n    const nextIndex = dir === 'rtl' ? _previousIndex : _nextIndex;\n    const previousIndex = dir === 'rtl' ? _nextIndex : _previousIndex;\n\n    switch (event.key) {\n      case 'ArrowRight': {\n        if (orientation === 'horizontal') {\n          event.stopPropagation();\n          event.preventDefault();\n          elements[nextIndex].focus();\n          activateOnFocus && elements[nextIndex].click();\n        }\n\n        break;\n      }\n\n      case 'ArrowLeft': {\n        if (orientation === 'horizontal') {\n          event.stopPropagation();\n          event.preventDefault();\n          elements[previousIndex].focus();\n          activateOnFocus && elements[previousIndex].click();\n        }\n\n        break;\n      }\n\n      case 'ArrowUp': {\n        if (orientation === 'vertical') {\n          event.stopPropagation();\n          event.preventDefault();\n          elements[_previousIndex].focus();\n          activateOnFocus && elements[_previousIndex].click();\n        }\n\n        break;\n      }\n\n      case 'ArrowDown': {\n        if (orientation === 'vertical') {\n          event.stopPropagation();\n          event.preventDefault();\n          elements[_nextIndex].focus();\n          activateOnFocus && elements[_nextIndex].click();\n        }\n\n        break;\n      }\n\n      case 'Home': {\n        event.stopPropagation();\n        event.preventDefault();\n        !elements[0].disabled && elements[0].focus();\n        break;\n      }\n\n      case 'End': {\n        event.stopPropagation();\n        event.preventDefault();\n        const last = elements.length - 1;\n        !elements[last].disabled && elements[last].focus();\n        break;\n      }\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}