{"ast":null,"code":"'use client';\n\nimport { useCallback, useState, useEffect } from 'react';\nimport { useWindowEvent } from '../use-window-event/use-window-event.mjs';\nfunction serializeJSON(value) {\n  let hookName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"use-local-storage\";\n  try {\n    return JSON.stringify(value);\n  } catch (error) {\n    throw new Error(\"@mantine/hooks \".concat(hookName, \": Failed to serialize the value\"));\n  }\n}\nfunction deserializeJSON(value) {\n  try {\n    return value && JSON.parse(value);\n  } catch (_unused) {\n    return value;\n  }\n}\nfunction createStorageHandler(type) {\n  const getItem = key => {\n    try {\n      return window[type].getItem(key);\n    } catch (error) {\n      console.warn(\"use-local-storage: Failed to get value from storage, localStorage is blocked\");\n      return null;\n    }\n  };\n  const setItem = (key, value) => {\n    try {\n      window[type].setItem(key, value);\n    } catch (error) {\n      console.warn(\"use-local-storage: Failed to set value to storage, localStorage is blocked\");\n    }\n  };\n  const removeItem = key => {\n    try {\n      window[type].removeItem(key);\n    } catch (error) {\n      console.warn(\"use-local-storage: Failed to remove value from storage, localStorage is blocked\");\n    }\n  };\n  return {\n    getItem,\n    setItem,\n    removeItem\n  };\n}\nfunction createStorage(type, hookName) {\n  const eventName = type === \"localStorage\" ? \"mantine-local-storage\" : \"mantine-session-storage\";\n  const {\n    getItem,\n    setItem,\n    removeItem\n  } = createStorageHandler(type);\n  return function useStorage(_ref) {\n    let {\n      key,\n      defaultValue,\n      getInitialValueInEffect = true,\n      sync = true,\n      deserialize = deserializeJSON,\n      serialize = value => serializeJSON(value, hookName)\n    } = _ref;\n    const readStorageValue = useCallback(skipStorage => {\n      let storageBlockedOrSkipped;\n      try {\n        storageBlockedOrSkipped = typeof window === \"undefined\" || !(type in window) || window[type] === null || !!skipStorage;\n      } catch (_e) {\n        storageBlockedOrSkipped = true;\n      }\n      if (storageBlockedOrSkipped) {\n        return defaultValue;\n      }\n      const storageValue = getItem(key);\n      return storageValue !== null ? deserialize(storageValue) : defaultValue;\n    }, [key, defaultValue]);\n    const [value, setValue] = useState(readStorageValue(getInitialValueInEffect));\n    const setStorageValue = useCallback(val => {\n      if (val instanceof Function) {\n        setValue(current => {\n          const result = val(current);\n          setItem(key, serialize(result));\n          queueMicrotask(() => {\n            window.dispatchEvent(new CustomEvent(eventName, {\n              detail: {\n                key,\n                value: val(current)\n              }\n            }));\n          });\n          return result;\n        });\n      } else {\n        setItem(key, serialize(val));\n        window.dispatchEvent(new CustomEvent(eventName, {\n          detail: {\n            key,\n            value: val\n          }\n        }));\n        setValue(val);\n      }\n    }, [key]);\n    const removeStorageValue = useCallback(() => {\n      removeItem(key);\n      setValue(defaultValue);\n      window.dispatchEvent(new CustomEvent(eventName, {\n        detail: {\n          key,\n          value: defaultValue\n        }\n      }));\n    }, [key, defaultValue]);\n    useWindowEvent(\"storage\", event => {\n      if (sync) {\n        if (event.storageArea === window[type] && event.key === key) {\n          var _event$newValue;\n          setValue(deserialize((_event$newValue = event.newValue) !== null && _event$newValue !== void 0 ? _event$newValue : void 0));\n        }\n      }\n    });\n    useWindowEvent(eventName, event => {\n      if (sync) {\n        if (event.detail.key === key) {\n          setValue(event.detail.value);\n        }\n      }\n    });\n    useEffect(() => {\n      if (defaultValue !== void 0 && value === void 0) {\n        setStorageValue(defaultValue);\n      }\n    }, [defaultValue, value, setStorageValue]);\n    useEffect(() => {\n      const val = readStorageValue();\n      val !== void 0 && setStorageValue(val);\n    }, [key]);\n    return [value === void 0 ? defaultValue : value, setStorageValue, removeStorageValue];\n  };\n}\nfunction readValue(type) {\n  const {\n    getItem\n  } = createStorageHandler(type);\n  return function read(_ref2) {\n    let {\n      key,\n      defaultValue,\n      deserialize = deserializeJSON\n    } = _ref2;\n    let storageBlockedOrSkipped;\n    try {\n      storageBlockedOrSkipped = typeof window === \"undefined\" || !(type in window) || window[type] === null;\n    } catch (_e) {\n      storageBlockedOrSkipped = true;\n    }\n    if (storageBlockedOrSkipped) {\n      return defaultValue;\n    }\n    const storageValue = getItem(key);\n    return storageValue !== null ? deserialize(storageValue) : defaultValue;\n  };\n}\nexport { createStorage, readValue };","map":{"version":3,"names":["serializeJSON","value","hookName","arguments","length","undefined","JSON","stringify","error","Error","concat","deserializeJSON","parse","_unused","createStorageHandler","type","getItem","key","window","console","warn","setItem","removeItem","createStorage","eventName","useStorage","_ref","defaultValue","getInitialValueInEffect","sync","deserialize","serialize","readStorageValue","useCallback","skipStorage","storageBlockedOrSkipped","_e","storageValue","setValue","useState","setStorageValue","val","Function","current","result","queueMicrotask","dispatchEvent","CustomEvent","detail","removeStorageValue","useWindowEvent","event","storageArea","_event$newValue","newValue","useEffect","readValue","read","_ref2"],"sources":["/Users/ansarzeinulla/Desktop/ctrl-freak/widget-frontend/node_modules/@mantine/hooks/src/use-local-storage/create-storage.ts"],"sourcesContent":["/* eslint-disable no-console */\nimport { useCallback, useEffect, useState } from 'react';\nimport { useWindowEvent } from '../use-window-event/use-window-event';\n\nexport type StorageType = 'localStorage' | 'sessionStorage';\n\nexport interface UseStorageOptions<T> {\n  /** Storage key */\n  key: string;\n\n  /** Default value that will be set if value is not found in storage */\n  defaultValue?: T;\n\n  /** If set to true, value will be updated in useEffect after mount. Default value is true. */\n  getInitialValueInEffect?: boolean;\n\n  /** Determines whether the value must be synced between browser tabs, `true` by default */\n  sync?: boolean;\n\n  /** Function to serialize value into string to be save in storage */\n  serialize?: (value: T) => string;\n\n  /** Function to deserialize string value from storage to value */\n  deserialize?: (value: string | undefined) => T;\n}\n\nfunction serializeJSON<T>(value: T, hookName: string = 'use-local-storage') {\n  try {\n    return JSON.stringify(value);\n  } catch (error) {\n    throw new Error(`@mantine/hooks ${hookName}: Failed to serialize the value`);\n  }\n}\n\nfunction deserializeJSON(value: string | undefined) {\n  try {\n    return value && JSON.parse(value);\n  } catch {\n    return value;\n  }\n}\n\nfunction createStorageHandler(type: StorageType) {\n  const getItem = (key: string) => {\n    try {\n      return window[type].getItem(key);\n    } catch (error) {\n      console.warn('use-local-storage: Failed to get value from storage, localStorage is blocked');\n      return null;\n    }\n  };\n\n  const setItem = (key: string, value: string) => {\n    try {\n      window[type].setItem(key, value);\n    } catch (error) {\n      console.warn('use-local-storage: Failed to set value to storage, localStorage is blocked');\n    }\n  };\n\n  const removeItem = (key: string) => {\n    try {\n      window[type].removeItem(key);\n    } catch (error) {\n      console.warn(\n        'use-local-storage: Failed to remove value from storage, localStorage is blocked'\n      );\n    }\n  };\n\n  return { getItem, setItem, removeItem };\n}\n\nexport type UseStorageReturnValue<T> = [\n  T, // current value\n  (val: T | ((prevState: T) => T)) => void, // callback to set value in storage\n  () => void, // callback to remove value from storage\n];\n\nexport function createStorage<T>(type: StorageType, hookName: string) {\n  const eventName = type === 'localStorage' ? 'mantine-local-storage' : 'mantine-session-storage';\n  const { getItem, setItem, removeItem } = createStorageHandler(type);\n\n  return function useStorage({\n    key,\n    defaultValue,\n    getInitialValueInEffect = true,\n    sync = true,\n    deserialize = deserializeJSON,\n    serialize = (value: T) => serializeJSON(value, hookName),\n  }: UseStorageOptions<T>): UseStorageReturnValue<T> {\n    const readStorageValue = useCallback(\n      (skipStorage?: boolean): T => {\n        let storageBlockedOrSkipped;\n\n        try {\n          storageBlockedOrSkipped =\n            typeof window === 'undefined' ||\n            !(type in window) ||\n            window[type] === null ||\n            !!skipStorage;\n        } catch (_e) {\n          storageBlockedOrSkipped = true;\n        }\n\n        if (storageBlockedOrSkipped) {\n          return defaultValue as T;\n        }\n\n        const storageValue = getItem(key);\n        return storageValue !== null ? deserialize(storageValue) : (defaultValue as T);\n      },\n      [key, defaultValue]\n    );\n\n    const [value, setValue] = useState<T>(readStorageValue(getInitialValueInEffect));\n\n    const setStorageValue = useCallback(\n      (val: T | ((prevState: T) => T)) => {\n        if (val instanceof Function) {\n          setValue((current) => {\n            const result = val(current);\n            setItem(key, serialize(result));\n            // Defer dispatching this event to avoid the handler being called during render.\n            queueMicrotask(() => {\n              window.dispatchEvent(\n                new CustomEvent(eventName, { detail: { key, value: val(current) } })\n              );\n            });\n            return result;\n          });\n        } else {\n          setItem(key, serialize(val));\n          window.dispatchEvent(new CustomEvent(eventName, { detail: { key, value: val } }));\n          setValue(val);\n        }\n      },\n      [key]\n    );\n\n    const removeStorageValue = useCallback(() => {\n      removeItem(key);\n      setValue(defaultValue as T);\n      window.dispatchEvent(new CustomEvent(eventName, { detail: { key, value: defaultValue } }));\n    }, [key, defaultValue]);\n\n    useWindowEvent('storage', (event) => {\n      if (sync) {\n        if (event.storageArea === window[type] && event.key === key) {\n          setValue(deserialize(event.newValue ?? undefined));\n        }\n      }\n    });\n\n    useWindowEvent(eventName, (event) => {\n      if (sync) {\n        if (event.detail.key === key) {\n          setValue(event.detail.value);\n        }\n      }\n    });\n\n    useEffect(() => {\n      if (defaultValue !== undefined && value === undefined) {\n        setStorageValue(defaultValue);\n      }\n    }, [defaultValue, value, setStorageValue]);\n\n    useEffect(() => {\n      const val = readStorageValue();\n      val !== undefined && setStorageValue(val);\n    }, [key]);\n\n    return [value === undefined ? (defaultValue as T) : value, setStorageValue, removeStorageValue];\n  };\n}\n\nexport function readValue(type: StorageType) {\n  const { getItem } = createStorageHandler(type);\n\n  return function read<T>({\n    key,\n    defaultValue,\n    deserialize = deserializeJSON,\n  }: UseStorageOptions<T>) {\n    let storageBlockedOrSkipped;\n\n    try {\n      storageBlockedOrSkipped =\n        typeof window === 'undefined' || !(type in window) || window[type] === null;\n    } catch (_e) {\n      storageBlockedOrSkipped = true;\n    }\n\n    if (storageBlockedOrSkipped) {\n      return defaultValue as T;\n    }\n\n    const storageValue = getItem(key);\n    return storageValue !== null ? deserialize(storageValue) : (defaultValue as T);\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}