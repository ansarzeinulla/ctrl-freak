{"ast":null,"code":"'use client';\n\nimport { useRef, useCallback, useEffect } from 'react';\nimport { useReducedMotion } from '../use-reduced-motion/use-reduced-motion.mjs';\nimport { useWindowEvent } from '../use-window-event/use-window-event.mjs';\nfunction useScrollIntoView({\n  duration = 1250,\n  axis = \"y\",\n  onScrollFinish,\n  easing = easeInOutQuad,\n  offset = 0,\n  cancelable = true,\n  isList = false\n} = {}) {\n  const frameID = useRef(0);\n  const startTime = useRef(0);\n  const shouldStop = useRef(false);\n  const scrollableRef = useRef(null);\n  const targetRef = useRef(null);\n  const reducedMotion = useReducedMotion();\n  const cancel = () => {\n    if (frameID.current) {\n      cancelAnimationFrame(frameID.current);\n    }\n  };\n  const scrollIntoView = useCallback(({\n    alignment = \"start\"\n  } = {}) => {\n    shouldStop.current = false;\n    if (frameID.current) {\n      cancel();\n    }\n    const start = getScrollStart({\n      parent: scrollableRef.current,\n      axis\n    }) ?? 0;\n    const change = getRelativePosition({\n      parent: scrollableRef.current,\n      target: targetRef.current,\n      axis,\n      alignment,\n      offset,\n      isList\n    }) - (scrollableRef.current ? 0 : start);\n    function animateScroll() {\n      if (startTime.current === 0) {\n        startTime.current = performance.now();\n      }\n      const now = performance.now();\n      const elapsed = now - startTime.current;\n      const t = reducedMotion || duration === 0 ? 1 : elapsed / duration;\n      const distance = start + change * easing(t);\n      setScrollParam({\n        parent: scrollableRef.current,\n        axis,\n        distance\n      });\n      if (!shouldStop.current && t < 1) {\n        frameID.current = requestAnimationFrame(animateScroll);\n      } else {\n        typeof onScrollFinish === \"function\" && onScrollFinish();\n        startTime.current = 0;\n        frameID.current = 0;\n        cancel();\n      }\n    }\n    animateScroll();\n  }, [axis, duration, easing, isList, offset, onScrollFinish, reducedMotion]);\n  const handleStop = () => {\n    if (cancelable) {\n      shouldStop.current = true;\n    }\n  };\n  useWindowEvent(\"wheel\", handleStop, {\n    passive: true\n  });\n  useWindowEvent(\"touchmove\", handleStop, {\n    passive: true\n  });\n  useEffect(() => cancel, []);\n  return {\n    scrollableRef,\n    targetRef,\n    scrollIntoView,\n    cancel\n  };\n}\nfunction easeInOutQuad(t) {\n  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n}\nfunction getRelativePosition({\n  axis,\n  target,\n  parent,\n  alignment,\n  offset,\n  isList\n}) {\n  if (!target || !parent && typeof document === \"undefined\") {\n    return 0;\n  }\n  const isCustomParent = !!parent;\n  const parentElement = parent || document.body;\n  const parentPosition = parentElement.getBoundingClientRect();\n  const targetPosition = target.getBoundingClientRect();\n  const getDiff = property => targetPosition[property] - parentPosition[property];\n  if (axis === \"y\") {\n    const diff = getDiff(\"top\");\n    if (diff === 0) {\n      return 0;\n    }\n    if (alignment === \"start\") {\n      const distance = diff - offset;\n      const shouldScroll = distance <= targetPosition.height * (isList ? 0 : 1) || !isList;\n      return shouldScroll ? distance : 0;\n    }\n    const parentHeight = isCustomParent ? parentPosition.height : window.innerHeight;\n    if (alignment === \"end\") {\n      const distance = diff + offset - parentHeight + targetPosition.height;\n      const shouldScroll = distance >= -targetPosition.height * (isList ? 0 : 1) || !isList;\n      return shouldScroll ? distance : 0;\n    }\n    if (alignment === \"center\") {\n      return diff - parentHeight / 2 + targetPosition.height / 2;\n    }\n    return 0;\n  }\n  if (axis === \"x\") {\n    const diff = getDiff(\"left\");\n    if (diff === 0) {\n      return 0;\n    }\n    if (alignment === \"start\") {\n      const distance = diff - offset;\n      const shouldScroll = distance <= targetPosition.width || !isList;\n      return shouldScroll ? distance : 0;\n    }\n    const parentWidth = isCustomParent ? parentPosition.width : window.innerWidth;\n    if (alignment === \"end\") {\n      const distance = diff + offset - parentWidth + targetPosition.width;\n      const shouldScroll = distance >= -targetPosition.width || !isList;\n      return shouldScroll ? distance : 0;\n    }\n    if (alignment === \"center\") {\n      return diff - parentWidth / 2 + targetPosition.width / 2;\n    }\n    return 0;\n  }\n  return 0;\n}\nfunction getScrollStart({\n  axis,\n  parent\n}) {\n  if (!parent && typeof document === \"undefined\") {\n    return 0;\n  }\n  const method = axis === \"y\" ? \"scrollTop\" : \"scrollLeft\";\n  if (parent) {\n    return parent[method];\n  }\n  const {\n    body,\n    documentElement\n  } = document;\n  return body[method] + documentElement[method];\n}\nfunction setScrollParam({\n  axis,\n  parent,\n  distance\n}) {\n  if (!parent && typeof document === \"undefined\") {\n    return;\n  }\n  const method = axis === \"y\" ? \"scrollTop\" : \"scrollLeft\";\n  if (parent) {\n    parent[method] = distance;\n  } else {\n    const {\n      body,\n      documentElement\n    } = document;\n    body[method] = distance;\n    documentElement[method] = distance;\n  }\n}\nexport { useScrollIntoView };","map":{"version":3,"names":["useScrollIntoView","duration","axis","onScrollFinish","easing","easeInOutQuad","offset","cancelable","isList","frameID","useRef","startTime","shouldStop","scrollableRef","targetRef","reducedMotion","useReducedMotion","cancel","current","cancelAnimationFrame","scrollIntoView","useCallback","alignment","start","getScrollStart","parent","change","getRelativePosition","target","animateScroll","performance","now","elapsed","t","distance","setScrollParam","requestAnimationFrame","handleStop","useWindowEvent","passive","useEffect","document","isCustomParent","parentElement","body","parentPosition","getBoundingClientRect","targetPosition","getDiff","property","diff","shouldScroll","height","parentHeight","window","innerHeight","width","parentWidth","innerWidth","method","documentElement"],"sources":["/Users/ansarzeinulla/Desktop/negro/widget-frontend/node_modules/@mantine/hooks/src/use-scroll-into-view/use-scroll-into-view.ts"],"sourcesContent":["import { useCallback, useEffect, useRef } from 'react';\nimport { useReducedMotion } from '../use-reduced-motion/use-reduced-motion';\nimport { useWindowEvent } from '../use-window-event/use-window-event';\n\ninterface UseScrollIntoViewAnimation {\n  /** Target element alignment relatively to parent based on current axis */\n  alignment?: 'start' | 'end' | 'center';\n}\n\nexport interface UseScrollIntoViewOptions {\n  /** Callback fired after scroll */\n  onScrollFinish?: () => void;\n\n  /** Duration of scroll in milliseconds */\n  duration?: number;\n\n  /** Axis of scroll */\n  axis?: 'x' | 'y';\n\n  /** Custom mathematical easing function */\n  easing?: (t: number) => number;\n\n  /** Additional distance between nearest edge and element */\n  offset?: number;\n\n  /** Indicator if animation may be interrupted by user scrolling */\n  cancelable?: boolean;\n\n  /** Prevents content jumping in scrolling lists with multiple targets */\n  isList?: boolean;\n}\n\nexport interface UseScrollIntoViewReturnValue<\n  Target extends HTMLElement = any,\n  Parent extends HTMLElement | null = null,\n> {\n  scrollableRef: React.RefObject<Parent | null>;\n  targetRef: React.RefObject<Target | null>;\n  scrollIntoView: (params?: UseScrollIntoViewAnimation) => void;\n  cancel: () => void;\n}\n\nexport function useScrollIntoView<\n  Target extends HTMLElement = any,\n  Parent extends HTMLElement | null = null,\n>({\n  duration = 1250,\n  axis = 'y',\n  onScrollFinish,\n  easing = easeInOutQuad,\n  offset = 0,\n  cancelable = true,\n  isList = false,\n}: UseScrollIntoViewOptions = {}): UseScrollIntoViewReturnValue<Target, Parent> {\n  const frameID = useRef(0);\n  const startTime = useRef(0);\n  const shouldStop = useRef(false);\n\n  const scrollableRef = useRef<Parent | null>(null);\n  const targetRef = useRef<Target | null>(null);\n\n  const reducedMotion = useReducedMotion();\n\n  const cancel = (): void => {\n    if (frameID.current) {\n      cancelAnimationFrame(frameID.current);\n    }\n  };\n\n  const scrollIntoView = useCallback(\n    ({ alignment = 'start' }: UseScrollIntoViewAnimation = {}) => {\n      shouldStop.current = false;\n\n      if (frameID.current) {\n        cancel();\n      }\n\n      const start = getScrollStart({ parent: scrollableRef.current, axis }) ?? 0;\n\n      const change =\n        getRelativePosition({\n          parent: scrollableRef.current,\n          target: targetRef.current,\n          axis,\n          alignment,\n          offset,\n          isList,\n        }) - (scrollableRef.current ? 0 : start);\n\n      function animateScroll() {\n        if (startTime.current === 0) {\n          startTime.current = performance.now();\n        }\n\n        const now = performance.now();\n        const elapsed = now - startTime.current;\n\n        // Easing timing progress\n        const t = reducedMotion || duration === 0 ? 1 : elapsed / duration;\n\n        const distance = start + change * easing(t);\n\n        setScrollParam({\n          parent: scrollableRef.current,\n          axis,\n          distance,\n        });\n\n        if (!shouldStop.current && t < 1) {\n          frameID.current = requestAnimationFrame(animateScroll);\n        } else {\n          typeof onScrollFinish === 'function' && onScrollFinish();\n          startTime.current = 0;\n          frameID.current = 0;\n          cancel();\n        }\n      }\n      animateScroll();\n    },\n    [axis, duration, easing, isList, offset, onScrollFinish, reducedMotion]\n  );\n\n  const handleStop = () => {\n    if (cancelable) {\n      shouldStop.current = true;\n    }\n  };\n\n  /**\n   * Detection of one of these events stops scroll animation\n   * wheel - mouse wheel / touch pad\n   * touchmove - any touchable device\n   */\n\n  useWindowEvent('wheel', handleStop, {\n    passive: true,\n  });\n\n  useWindowEvent('touchmove', handleStop, {\n    passive: true,\n  });\n\n  // Cleanup requestAnimationFrame\n  useEffect(() => cancel, []);\n\n  return {\n    scrollableRef,\n    targetRef,\n    scrollIntoView,\n    cancel,\n  };\n}\n\n// ---------------------------------------------------\n// Helpers\n// ---------------------------------------------------\n\nfunction easeInOutQuad(t: number) {\n  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n}\n\nfunction getRelativePosition({ axis, target, parent, alignment, offset, isList }: any): number {\n  if (!target || (!parent && typeof document === 'undefined')) {\n    return 0;\n  }\n  const isCustomParent = !!parent;\n  const parentElement = parent || document.body;\n  const parentPosition = parentElement.getBoundingClientRect();\n  const targetPosition = target.getBoundingClientRect();\n\n  const getDiff = (property: 'top' | 'left'): number =>\n    targetPosition[property] - parentPosition[property];\n\n  if (axis === 'y') {\n    const diff = getDiff('top');\n\n    if (diff === 0) {\n      return 0;\n    }\n\n    if (alignment === 'start') {\n      const distance = diff - offset;\n      const shouldScroll = distance <= targetPosition.height * (isList ? 0 : 1) || !isList;\n\n      return shouldScroll ? distance : 0;\n    }\n\n    const parentHeight = isCustomParent ? parentPosition.height : window.innerHeight;\n\n    if (alignment === 'end') {\n      const distance = diff + offset - parentHeight + targetPosition.height;\n      const shouldScroll = distance >= -targetPosition.height * (isList ? 0 : 1) || !isList;\n\n      return shouldScroll ? distance : 0;\n    }\n\n    if (alignment === 'center') {\n      return diff - parentHeight / 2 + targetPosition.height / 2;\n    }\n\n    return 0;\n  }\n\n  if (axis === 'x') {\n    const diff = getDiff('left');\n\n    if (diff === 0) {\n      return 0;\n    }\n\n    if (alignment === 'start') {\n      const distance = diff - offset;\n      const shouldScroll = distance <= targetPosition.width || !isList;\n\n      return shouldScroll ? distance : 0;\n    }\n\n    const parentWidth = isCustomParent ? parentPosition.width : window.innerWidth;\n\n    if (alignment === 'end') {\n      const distance = diff + offset - parentWidth + targetPosition.width;\n      const shouldScroll = distance >= -targetPosition.width || !isList;\n\n      return shouldScroll ? distance : 0;\n    }\n\n    if (alignment === 'center') {\n      return diff - parentWidth / 2 + targetPosition.width / 2;\n    }\n\n    return 0;\n  }\n\n  return 0;\n}\n\nfunction getScrollStart({ axis, parent }: any) {\n  if (!parent && typeof document === 'undefined') {\n    return 0;\n  }\n\n  const method = axis === 'y' ? 'scrollTop' : 'scrollLeft';\n\n  if (parent) {\n    return parent[method];\n  }\n\n  const { body, documentElement } = document;\n\n  // While one of it has a value the second is equal 0\n  return body[method] + documentElement[method];\n}\n\nfunction setScrollParam({ axis, parent, distance }: any) {\n  if (!parent && typeof document === 'undefined') {\n    return;\n  }\n\n  const method = axis === 'y' ? 'scrollTop' : 'scrollLeft';\n\n  if (parent) {\n    parent[method] = distance;\n  } else {\n    const { body, documentElement } = document;\n    body[method] = distance;\n    documentElement[method] = distance;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}