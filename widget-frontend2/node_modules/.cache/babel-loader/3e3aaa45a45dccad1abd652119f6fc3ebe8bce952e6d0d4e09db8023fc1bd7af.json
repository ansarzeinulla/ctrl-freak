{"ast":null,"code":"'use client';\n\nimport { useRef, useState, useEffect } from 'react';\nimport { useIsomorphicEffect } from '../use-isomorphic-effect/use-isomorphic-effect.mjs';\nimport { useWindowScroll } from '../use-window-scroll/use-window-scroll.mjs';\nconst isFixed = (current, fixedAt) => current <= fixedAt;\nconst isPinnedOrReleased = (current, fixedAt, isCurrentlyPinnedRef, isScrollingUp, onPin, onRelease) => {\n  const isInFixedPosition = isFixed(current, fixedAt);\n  if (isInFixedPosition && !isCurrentlyPinnedRef.current) {\n    isCurrentlyPinnedRef.current = true;\n    onPin === null || onPin === void 0 || onPin();\n  } else if (!isInFixedPosition && isScrollingUp && !isCurrentlyPinnedRef.current) {\n    isCurrentlyPinnedRef.current = true;\n    onPin === null || onPin === void 0 || onPin();\n  } else if (!isInFixedPosition && isCurrentlyPinnedRef.current) {\n    isCurrentlyPinnedRef.current = false;\n    onRelease === null || onRelease === void 0 || onRelease();\n  }\n};\nconst useScrollDirection = () => {\n  const [lastScrollTop, setLastScrollTop] = useState(0);\n  const [isScrollingUp, setIsScrollingUp] = useState(false);\n  const [isResizing, setIsResizing] = useState(false);\n  useEffect(() => {\n    let resizeTimer;\n    const onResize = () => {\n      setIsResizing(true);\n      clearTimeout(resizeTimer);\n      resizeTimer = setTimeout(() => {\n        setIsResizing(false);\n      }, 300);\n    };\n    const onScroll = () => {\n      if (isResizing) {\n        return;\n      }\n      const currentScrollTop = window.scrollY || document.documentElement.scrollTop;\n      setIsScrollingUp(currentScrollTop < lastScrollTop);\n      setLastScrollTop(currentScrollTop);\n    };\n    window.addEventListener(\"scroll\", onScroll);\n    window.addEventListener(\"resize\", onResize);\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll);\n      window.removeEventListener(\"resize\", onResize);\n    };\n  }, [lastScrollTop, isResizing]);\n  return isScrollingUp;\n};\nfunction useHeadroom() {\n  let {\n    fixedAt = 0,\n    onPin,\n    onFix,\n    onRelease\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const isCurrentlyPinnedRef = useRef(false);\n  const isScrollingUp = useScrollDirection();\n  const [{\n    y: scrollPosition\n  }] = useWindowScroll();\n  useIsomorphicEffect(() => {\n    isPinnedOrReleased(scrollPosition, fixedAt, isCurrentlyPinnedRef, isScrollingUp, onPin, onRelease);\n  }, [scrollPosition]);\n  useIsomorphicEffect(() => {\n    if (isFixed(scrollPosition, fixedAt)) {\n      onFix === null || onFix === void 0 || onFix();\n    }\n  }, [scrollPosition, fixedAt, onFix]);\n  if (isFixed(scrollPosition, fixedAt) || isScrollingUp) {\n    return true;\n  }\n  return false;\n}\nexport { isFixed, isPinnedOrReleased, useHeadroom, useScrollDirection };","map":{"version":3,"names":["isFixed","current","fixedAt","isPinnedOrReleased","isCurrentlyPinnedRef","isScrollingUp","onPin","onRelease","isInFixedPosition","useScrollDirection","lastScrollTop","setLastScrollTop","useState","setIsScrollingUp","isResizing","setIsResizing","useEffect","resizeTimer","onResize","clearTimeout","setTimeout","onScroll","currentScrollTop","window","scrollY","document","documentElement","scrollTop","addEventListener","removeEventListener","useHeadroom","onFix","arguments","length","undefined","useRef","y","scrollPosition","useWindowScroll","useIsomorphicEffect"],"sources":["/Users/ansarzeinulla/Desktop/negro/widget-frontend/node_modules/@mantine/hooks/src/use-headroom/use-headroom.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\nimport { useIsomorphicEffect } from '../use-isomorphic-effect/use-isomorphic-effect';\nimport { useWindowScroll } from '../use-window-scroll/use-window-scroll';\n\nexport const isFixed = (current: number, fixedAt: number) => current <= fixedAt;\nexport const isPinned = (current: number, previous: number) => current <= previous;\nexport const isReleased = (current: number, previous: number, fixedAt: number) =>\n  !isPinned(current, previous) && !isFixed(current, fixedAt);\n\nexport const isPinnedOrReleased = (\n  current: number,\n  fixedAt: number,\n  isCurrentlyPinnedRef: React.RefObject<boolean>,\n  isScrollingUp: boolean,\n  onPin?: () => void,\n  onRelease?: () => void\n) => {\n  const isInFixedPosition = isFixed(current, fixedAt);\n  if (isInFixedPosition && !isCurrentlyPinnedRef.current) {\n    isCurrentlyPinnedRef.current = true;\n    onPin?.();\n  } else if (!isInFixedPosition && isScrollingUp && !isCurrentlyPinnedRef.current) {\n    isCurrentlyPinnedRef.current = true;\n    onPin?.();\n  } else if (!isInFixedPosition && isCurrentlyPinnedRef.current) {\n    isCurrentlyPinnedRef.current = false;\n    onRelease?.();\n  }\n};\n\nexport const useScrollDirection = () => {\n  const [lastScrollTop, setLastScrollTop] = useState(0);\n  const [isScrollingUp, setIsScrollingUp] = useState(false);\n  const [isResizing, setIsResizing] = useState(false);\n\n  useEffect(() => {\n    let resizeTimer: NodeJS.Timeout | undefined;\n\n    const onResize = () => {\n      setIsResizing(true);\n      clearTimeout(resizeTimer);\n      resizeTimer = setTimeout(() => {\n        setIsResizing(false);\n      }, 300); // Reset the resizing flag after a timeout\n    };\n\n    const onScroll = () => {\n      if (isResizing) {\n        return; // Skip scroll events if resizing is in progress\n      }\n      const currentScrollTop = window.scrollY || document.documentElement.scrollTop;\n      setIsScrollingUp(currentScrollTop < lastScrollTop);\n      setLastScrollTop(currentScrollTop);\n    };\n\n    window.addEventListener('scroll', onScroll);\n    window.addEventListener('resize', onResize);\n\n    return () => {\n      window.removeEventListener('scroll', onScroll);\n      window.removeEventListener('resize', onResize);\n    };\n  }, [lastScrollTop, isResizing]);\n\n  return isScrollingUp;\n};\n\nexport interface UseHeadroomOptions {\n  /** Number in px at which element should be fixed */\n  fixedAt?: number;\n\n  /** Called when element is pinned */\n  onPin?: () => void;\n\n  /** Called when element is at fixed position */\n  onFix?: () => void;\n\n  /** Called when element is unpinned */\n  onRelease?: () => void;\n}\n\nexport function useHeadroom({ fixedAt = 0, onPin, onFix, onRelease }: UseHeadroomOptions = {}) {\n  const isCurrentlyPinnedRef = useRef(false);\n  const isScrollingUp = useScrollDirection();\n  const [{ y: scrollPosition }] = useWindowScroll();\n\n  useIsomorphicEffect(() => {\n    isPinnedOrReleased(\n      scrollPosition,\n      fixedAt,\n      isCurrentlyPinnedRef,\n      isScrollingUp,\n      onPin,\n      onRelease\n    );\n  }, [scrollPosition]);\n\n  useIsomorphicEffect(() => {\n    if (isFixed(scrollPosition, fixedAt)) {\n      onFix?.();\n    }\n  }, [scrollPosition, fixedAt, onFix]);\n\n  if (isFixed(scrollPosition, fixedAt) || isScrollingUp) {\n    return true;\n  }\n\n  return false;\n}\n"],"mappings":";;;;;AAIO,MAAMA,OAAA,GAAUA,CAACC,OAAA,EAAiBC,OAAA,KAAoBD,OAAA,IAAWC,OAAA;AAKjE,MAAMC,kBAAA,GAAqBA,CAChCF,OAAA,EACAC,OAAA,EACAE,oBAAA,EACAC,aAAA,EACAC,KAAA,EACAC,SAAA,KACG;EACH,MAAMC,iBAAA,GAAoBR,OAAA,CAAQC,OAAA,EAASC,OAAO;EAClD,IAAIM,iBAAA,IAAqB,CAACJ,oBAAA,CAAqBH,OAAA,EAAS;IACtDG,oBAAA,CAAqBH,OAAA,GAAU;IAC/BK,KAAA,aAAAA,KAAA,eAAAA,KAAA,EAAQ;EACV,WAAW,CAACE,iBAAA,IAAqBH,aAAA,IAAiB,CAACD,oBAAA,CAAqBH,OAAA,EAAS;IAC/EG,oBAAA,CAAqBH,OAAA,GAAU;IAC/BK,KAAA,aAAAA,KAAA,eAAAA,KAAA,EAAQ;EACV,WAAW,CAACE,iBAAA,IAAqBJ,oBAAA,CAAqBH,OAAA,EAAS;IAC7DG,oBAAA,CAAqBH,OAAA,GAAU;IAC/BM,SAAA,aAAAA,SAAA,eAAAA,SAAA,EAAY;EACd;AACF;AAEO,MAAME,kBAAA,GAAqBA,CAAA,KAAM;EACtC,MAAM,CAACC,aAAA,EAAeC,gBAAgB,IAAIC,QAAA,CAAS,CAAC;EACpD,MAAM,CAACP,aAAA,EAAeQ,gBAAgB,IAAID,QAAA,CAAS,KAAK;EACxD,MAAM,CAACE,UAAA,EAAYC,aAAa,IAAIH,QAAA,CAAS,KAAK;EAElDI,SAAA,CAAU,MAAM;IACd,IAAIC,WAAA;IAEJ,MAAMC,QAAA,GAAWA,CAAA,KAAM;MACrBH,aAAA,CAAc,IAAI;MAClBI,YAAA,CAAaF,WAAW;MACxBA,WAAA,GAAcG,UAAA,CAAW,MAAM;QAC7BL,aAAA,CAAc,KAAK;MACrB,GAAG,GAAG;IACR;IAEA,MAAMM,QAAA,GAAWA,CAAA,KAAM;MACrB,IAAIP,UAAA,EAAY;QACd;MACF;MACA,MAAMQ,gBAAA,GAAmBC,MAAA,CAAOC,OAAA,IAAWC,QAAA,CAASC,eAAA,CAAgBC,SAAA;MACpEd,gBAAA,CAAiBS,gBAAA,GAAmBZ,aAAa;MACjDC,gBAAA,CAAiBW,gBAAgB;IACnC;IAEAC,MAAA,CAAOK,gBAAA,CAAiB,UAAUP,QAAQ;IAC1CE,MAAA,CAAOK,gBAAA,CAAiB,UAAUV,QAAQ;IAE1C,OAAO,MAAM;MACXK,MAAA,CAAOM,mBAAA,CAAoB,UAAUR,QAAQ;MAC7CE,MAAA,CAAOM,mBAAA,CAAoB,UAAUX,QAAQ;IAC/C;EACF,GAAG,CAACR,aAAA,EAAeI,UAAU,CAAC;EAE9B,OAAOT,aAAA;AACT;AAgBO,SAASyB,YAAA,EAA+E;EAAA,IAAnE;IAAE5B,OAAA,GAAU;IAAGI,KAAA;IAAOyB,KAAA;IAAOxB;EAAA,CAAU,GAAAyB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAwB,EAAC;EAC1F,MAAM5B,oBAAA,GAAuB+B,MAAA,CAAO,KAAK;EACzC,MAAM9B,aAAA,GAAgBI,kBAAA,EAAmB;EACzC,MAAM,CAAC;IAAE2B,CAAA,EAAGC;EAAA,CAAgB,IAAIC,eAAA,EAAgB;EAEhDC,mBAAA,CAAoB,MAAM;IACxBpC,kBAAA,CACEkC,cAAA,EACAnC,OAAA,EACAE,oBAAA,EACAC,aAAA,EACAC,KAAA,EACAC,SAAA,CACF;EACF,GAAG,CAAC8B,cAAc,CAAC;EAEnBE,mBAAA,CAAoB,MAAM;IACxB,IAAIvC,OAAA,CAAQqC,cAAA,EAAgBnC,OAAO,GAAG;MACpC6B,KAAA,aAAAA,KAAA,eAAAA,KAAA,EAAQ;IACV;EACF,GAAG,CAACM,cAAA,EAAgBnC,OAAA,EAAS6B,KAAK,CAAC;EAEnC,IAAI/B,OAAA,CAAQqC,cAAA,EAAgBnC,OAAO,KAAKG,aAAA,EAAe;IACrD,OAAO;EACT;EAEA,OAAO;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}