{"ast":null,"code":"'use client';\n\nimport { useCallback } from 'react';\nfunction assignRef(ref, value) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  } else if (typeof ref === \"object\" && ref !== null && \"current\" in ref) {\n    ref.current = value;\n  }\n}\nfunction mergeRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n  const cleanupMap = /* @__PURE__ */new Map();\n  return node => {\n    refs.forEach(ref => {\n      const cleanup = assignRef(ref, node);\n      if (cleanup) {\n        cleanupMap.set(ref, cleanup);\n      }\n    });\n    if (cleanupMap.size > 0) {\n      return () => {\n        refs.forEach(ref => {\n          const cleanup = cleanupMap.get(ref);\n          if (cleanup && typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            assignRef(ref, null);\n          }\n        });\n        cleanupMap.clear();\n      };\n    }\n  };\n}\nfunction useMergedRef() {\n  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    refs[_key2] = arguments[_key2];\n  }\n  return useCallback(mergeRefs(...refs), refs);\n}\nexport { assignRef, mergeRefs, useMergedRef };","map":{"version":3,"names":["assignRef","ref","value","current","mergeRefs","_len","arguments","length","refs","Array","_key","cleanupMap","Map","node","forEach","cleanup","set","size","get","clear","useMergedRef","_len2","_key2","useCallback"],"sources":["/Users/ansarzeinulla/Desktop/negro/widget-frontend/node_modules/@mantine/hooks/src/use-merged-ref/use-merged-ref.ts"],"sourcesContent":["import { Ref, useCallback, type RefCallback } from 'react';\n\ntype PossibleRef<T> = Ref<T> | undefined;\n\ntype RefCleanup<T> = ReturnType<RefCallback<T>>;\n\nexport function assignRef<T>(ref: PossibleRef<T>, value: T): RefCleanup<T> {\n  if (typeof ref === 'function') {\n    return ref(value);\n  } else if (typeof ref === 'object' && ref !== null && 'current' in ref) {\n    ref.current = value;\n  }\n}\n\nexport function mergeRefs<T>(...refs: PossibleRef<T>[]): RefCallback<T> {\n  const cleanupMap = new Map<PossibleRef<T>, Exclude<RefCleanup<T>, void>>();\n\n  return (node: T | null) => {\n    refs.forEach((ref) => {\n      const cleanup = assignRef(ref, node);\n      if (cleanup) {\n        cleanupMap.set(ref, cleanup);\n      }\n    });\n\n    if (cleanupMap.size > 0) {\n      return () => {\n        refs.forEach((ref) => {\n          const cleanup = cleanupMap.get(ref);\n          if (cleanup && typeof cleanup === 'function') {\n            cleanup();\n          } else {\n            assignRef(ref, null);\n          }\n        });\n        cleanupMap.clear();\n      };\n    }\n  };\n}\n\nexport function useMergedRef<T>(...refs: PossibleRef<T>[]) {\n  return useCallback(mergeRefs(...refs), refs);\n}\n"],"mappings":";;;AAMO,SAASA,UAAaC,GAAA,EAAqBC,KAAA,EAAyB;EACzE,IAAI,OAAOD,GAAA,KAAQ,YAAY;IAC7B,OAAOA,GAAA,CAAIC,KAAK;EAClB,WAAW,OAAOD,GAAA,KAAQ,YAAYA,GAAA,KAAQ,QAAQ,aAAaA,GAAA,EAAK;IACtEA,GAAA,CAAIE,OAAA,GAAUD,KAAA;EAChB;AACF;AAEO,SAASE,UAAA,EAAwD;EAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAxCC,IAAA,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;IAAAF,IAAA,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;EAAA;EAC9B,MAAMC,UAAA,sBAAiBC,GAAA,EAAkD;EAEzE,OAAQC,IAAA,IAAmB;IACzBL,IAAA,CAAKM,OAAA,CAASb,GAAA,IAAQ;MACpB,MAAMc,OAAA,GAAUf,SAAA,CAAUC,GAAA,EAAKY,IAAI;MACnC,IAAIE,OAAA,EAAS;QACXJ,UAAA,CAAWK,GAAA,CAAIf,GAAA,EAAKc,OAAO;MAC7B;IACF,CAAC;IAED,IAAIJ,UAAA,CAAWM,IAAA,GAAO,GAAG;MACvB,OAAO,MAAM;QACXT,IAAA,CAAKM,OAAA,CAASb,GAAA,IAAQ;UACpB,MAAMc,OAAA,GAAUJ,UAAA,CAAWO,GAAA,CAAIjB,GAAG;UAClC,IAAIc,OAAA,IAAW,OAAOA,OAAA,KAAY,YAAY;YAC5CA,OAAA,EAAQ;UACV,OAAO;YACLf,SAAA,CAAUC,GAAA,EAAK,IAAI;UACrB;QACF,CAAC;QACDU,UAAA,CAAWQ,KAAA,EAAM;MACnB;IACF;EACF;AACF;AAEO,SAASC,aAAA,EAA2C;EAAA,SAAAC,KAAA,GAAAf,SAAA,CAAAC,MAAA,EAAxBC,IAAA,OAAAC,KAAA,CAAAY,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;IAAAd,IAAA,CAAAc,KAAA,IAAAhB,SAAA,CAAAgB,KAAA;EAAA;EACjC,OAAOC,WAAA,CAAYnB,SAAA,CAAU,GAAGI,IAAI,GAAGA,IAAI;AAC7C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}